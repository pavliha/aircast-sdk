"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: proto/common.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceStatus = exports.InterfaceInfo = exports.Camera = exports.SignalQuality = exports.Event = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "aircast.protocol.common";
function createBaseEvent() {
    return { name: "", type: "", payload: new Uint8Array(0) };
}
exports.Event = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.payload.length !== 0) {
            writer.uint32(26).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.payload.length !== 0) {
            obj.payload = base64FromBytes(message.payload);
        }
        return obj;
    },
    create(base) {
        return exports.Event.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEvent();
        message.name = object.name ?? "";
        message.type = object.type ?? "";
        message.payload = object.payload ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSignalQuality() {
    return { value: 0 };
}
exports.SignalQuality = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.value !== 0) {
            writer.uint32(8).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignalQuality();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.value = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        return obj;
    },
    create(base) {
        return exports.SignalQuality.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSignalQuality();
        message.value = object.value ?? 0;
        return message;
    },
};
function createBaseCamera() {
    return { id: "", name: "", rtspUrl: "", networkInterface: "" };
}
exports.Camera = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.rtspUrl !== "") {
            writer.uint32(26).string(message.rtspUrl);
        }
        if (message.networkInterface !== "") {
            writer.uint32(34).string(message.networkInterface);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCamera();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.rtspUrl = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.networkInterface = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            rtspUrl: isSet(object.rtspUrl) ? globalThis.String(object.rtspUrl) : "",
            networkInterface: isSet(object.networkInterface) ? globalThis.String(object.networkInterface) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.rtspUrl !== "") {
            obj.rtspUrl = message.rtspUrl;
        }
        if (message.networkInterface !== "") {
            obj.networkInterface = message.networkInterface;
        }
        return obj;
    },
    create(base) {
        return exports.Camera.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCamera();
        message.id = object.id ?? "";
        message.name = object.name ?? "";
        message.rtspUrl = object.rtspUrl ?? "";
        message.networkInterface = object.networkInterface ?? "";
        return message;
    },
};
function createBaseInterfaceInfo() {
    return { name: "", mtu: 0, hardwareAddr: "", flags: "", addresses: [] };
}
exports.InterfaceInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.mtu !== 0) {
            writer.uint32(16).int32(message.mtu);
        }
        if (message.hardwareAddr !== "") {
            writer.uint32(26).string(message.hardwareAddr);
        }
        if (message.flags !== "") {
            writer.uint32(34).string(message.flags);
        }
        for (const v of message.addresses) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInterfaceInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.mtu = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.hardwareAddr = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.flags = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.addresses.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            mtu: isSet(object.mtu) ? globalThis.Number(object.mtu) : 0,
            hardwareAddr: isSet(object.hardwareAddr) ? globalThis.String(object.hardwareAddr) : "",
            flags: isSet(object.flags) ? globalThis.String(object.flags) : "",
            addresses: globalThis.Array.isArray(object?.addresses)
                ? object.addresses.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.mtu !== 0) {
            obj.mtu = Math.round(message.mtu);
        }
        if (message.hardwareAddr !== "") {
            obj.hardwareAddr = message.hardwareAddr;
        }
        if (message.flags !== "") {
            obj.flags = message.flags;
        }
        if (message.addresses?.length) {
            obj.addresses = message.addresses;
        }
        return obj;
    },
    create(base) {
        return exports.InterfaceInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInterfaceInfo();
        message.name = object.name ?? "";
        message.mtu = object.mtu ?? 0;
        message.hardwareAddr = object.hardwareAddr ?? "";
        message.flags = object.flags ?? "";
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
    },
};
function createBaseServiceStatus() {
    return { mavlink: undefined, rtsp: undefined, modem: undefined, webrtc: undefined };
}
exports.ServiceStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mavlink !== undefined) {
            exports.Event.encode(message.mavlink, writer.uint32(10).fork()).ldelim();
        }
        if (message.rtsp !== undefined) {
            exports.Event.encode(message.rtsp, writer.uint32(18).fork()).ldelim();
        }
        if (message.modem !== undefined) {
            exports.Event.encode(message.modem, writer.uint32(26).fork()).ldelim();
        }
        if (message.webrtc !== undefined) {
            exports.Event.encode(message.webrtc, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServiceStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mavlink = exports.Event.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.rtsp = exports.Event.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.modem = exports.Event.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.webrtc = exports.Event.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mavlink: isSet(object.mavlink) ? exports.Event.fromJSON(object.mavlink) : undefined,
            rtsp: isSet(object.rtsp) ? exports.Event.fromJSON(object.rtsp) : undefined,
            modem: isSet(object.modem) ? exports.Event.fromJSON(object.modem) : undefined,
            webrtc: isSet(object.webrtc) ? exports.Event.fromJSON(object.webrtc) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mavlink !== undefined) {
            obj.mavlink = exports.Event.toJSON(message.mavlink);
        }
        if (message.rtsp !== undefined) {
            obj.rtsp = exports.Event.toJSON(message.rtsp);
        }
        if (message.modem !== undefined) {
            obj.modem = exports.Event.toJSON(message.modem);
        }
        if (message.webrtc !== undefined) {
            obj.webrtc = exports.Event.toJSON(message.webrtc);
        }
        return obj;
    },
    create(base) {
        return exports.ServiceStatus.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServiceStatus();
        message.mavlink = (object.mavlink !== undefined && object.mavlink !== null)
            ? exports.Event.fromPartial(object.mavlink)
            : undefined;
        message.rtsp = (object.rtsp !== undefined && object.rtsp !== null) ? exports.Event.fromPartial(object.rtsp) : undefined;
        message.modem = (object.modem !== undefined && object.modem !== null) ? exports.Event.fromPartial(object.modem) : undefined;
        message.webrtc = (object.webrtc !== undefined && object.webrtc !== null)
            ? exports.Event.fromPartial(object.webrtc)
            : undefined;
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
